[{"url":"https://en.wikipedia.org/wiki?curid=1360091","text":"Backpropagation\n\nBackpropagation is a method used in artificial neural networks to calculate the error contribution of each neuron after a batch of data (in image recognition, multiple images) is processed. It is a special case of an older and more general technique called automatic differentiation. In the context of learning, backpropagation is commonly used by the gradient descent optimization algorithm to adjust the weight of neurons by calculating the gradient of the loss function. This technique is also sometimes called backward propagation of errors, because the error is calculated at the output and distributed back through the network layers.\n\nThe backpropagation algorithm has been repeatedly rediscovered and is equivalent to automatic differentiation in reverse accumulation mode.\nBackpropagation requires a known, desired output for each input value—it is therefore considered to be a supervised learning method (although it is used in some unsupervised networks such as autoencoders). Backpropagation is also a generalization of the delta rule to multi-layered feedforward networks, made possible by using the chain rule to iteratively compute gradients for each layer. It is closely related to the Gauss–Newton algorithm, and is part of continuing research in neural backpropagation. Backpropagation can be used with any gradient-based optimizer, such as L-BFGS or truncated Newton. \n\nBackpropagation is commonly used to train deep neural networks , a term used to describe neural networks with more than one hidden layer. \n\nThe goal of any supervised learning algorithm is to find a function that best maps a set of inputs to their correct output. An example would be a classification task, where the input is an image of an animal, and the correct output is the name of the animal.\n\nThe motivation for backpropagation is to train a multi-layered neural network such that it can learn the appropriate internal representations to allow it to learn any arbitrary mapping of input to output.\n\nSometimes referred to as the cost function or error function (not to be confused with the Gauss error function), the loss function is a function that maps values of one or more variables onto a real number intuitively representing some \"cost\" associated with those values. For backpropagation, the loss function calculates the difference between the network output and its expected output, after a case propagates through the network. \n\nTwo assumptions must be made about the form of the error function. The first is that it can be written as an average formula_1 over error functions formula_2, for formula_3 individual training examples, formula_4. The reason for this assumption is that the backpropagation algorithm calculates the gradient of the error function for a single training example, which needs to be generalized to the overall error function. The second assumption is that it can be written as a function of the outputs from the neural network.\n\nLet formula_5 be vectors in formula_6.\n\nSelect an error function formula_7 measuring the difference between two outputs. The standard choice is the square of the Euclidean distance between the vectors formula_8 and formula_9:\n\nformula_10 ()\n\nNote that the factor of formula_11 conveniently cancels the exponent when the error function is subsequently differentiated. \n\nThe error function over formula_3 training examples can simply be written as an average of losses over individual examples:formula_13\n\nand therefore, the partial derivative with respect to the outputs:formula_14\n\nThe optimization algorithm repeats a two phase cycle, propagation and weight update. When an input vector is presented to the network, it is propagated forward through the network, layer by layer, until it reaches the output layer. The output of the network is then compared to the desired output, using a loss function. The resulting error value is calculated for each of the neurons in the output layer. The error values are then propagated from the output back through the network, until each neuron has an associated error value that reflects its contribution to the original output.\n\nBackpropagation uses these error values to calculate the gradient of the loss function. In the second phase, this gradient is fed to the optimization method, which in turn uses it to update the weights, in an attempt to minimize the loss function.\n\nLet formula_15 be a neural network with formula_16 connections, formula_17 inputs, and formula_18 outputs.\n\nBelow, formula_19 will denote vectors in formula_20, formula_21 vectors in formula_6, and formula_23 vectors in formula_24. \nThese are called \"inputs\", \"outputs\" and \"weights\" respectively.\n\nThe neural network corresponds to a function formula_25 which, given a weight formula_26, maps an input formula_27 to an output formula_8.\n\nThe optimization takes as input a sequence of \"training examples\" formula_29 and produces a sequence of weights formula_30 starting from some initial weight formula_31, usually chosen at random.\n\nThese weights are computed in turn: first compute formula_32 using only formula_33 for formula_34. The output of the algorithm is then formula_35, giving us a new function formula_36. The computation is the same in each step, hence only the case formula_37 is described.\n\nCalculating formula_38 from formula_39 is done by considering a variable weight formula_26 and applying gradient descent to the function formula_41 to find a local minimum, \nstarting at formula_42.\n\nThis makes formula_38 the minimizing weight found by gradient descent.\n\nTo implement the algorithm above, explicit formulas are required for the gradient of the function formula_44 where the function isformula_45.\n\nThe learning algorithm can be divided into two phases: propagation and weight update.\n\nEach propagation involves the following steps:\n\n\nFor each weight, the following steps must be followed:\nThis ratio (percentage) influences the speed and quality of learning; it is called the \"learning rate\". The greater the ratio, the faster the neuron trains, but the lower the ratio, the more accurate the training is. The sign of the gradient of a weight indicates whether the error varies directly with, or inversely to, the weight. Therefore, the weight must be updated in the opposite direction, \"descending\" the gradient.\n\nLearning is repeated (on new batches) until the network performs adequately.\n\nThe following is pseudocode for a stochastic gradient descent algorithm for training a three-layer network (only one hidden layer):\n\nThe lines labeled \"backward pass\" can be implemented using the backpropagation algorithm, which calculates the gradient of the error of the network regarding the network's modifiable weights. \n\nTo understand the mathematical derivation of the backpropagation algorithm, it helps to first develop some intuitions about the relationship between the actual output of a neuron and the correct output for a particular training case. Consider a simple neural network with two input units, one output unit and no hidden units. Each neuron uses a linear output that is the weighted sum of its input. \n\nInitially, before training, the weights will be set randomly. Then the neuron learns from training examples, which in this case consists of a set of tuples formula_46 where formula_47 and formula_48 are the inputs to the network and is the correct output (the output the network should eventually produce given those inputs). The initial network, given formula_47 and formula_48, will compute an output that likely differs from (given random weights). A common method for measuring the discrepancy between the expected output and the actual output is the squared error measure:\n\nwhere is the discrepancy or error.\n\nAs an example, consider the network on a single training case: formula_52, thus the input formula_47 and formula_48 are 1 and 1 respectively and the correct output, is 0. Now if the actual output is plotted on the horizontal axis against the error on the vertical axis, the result is a parabola. The minimum of the parabola corresponds to the output which minimizes the error . For a single training case, the minimum also touches the horizontal axis, which means the error will be zero and the network can produce an output that exactly matches the expected output . Therefore, the problem of mapping inputs to outputs can be reduced to an optimization problem of finding a function that will produce the minimal error. \n\nHowever, the output of a neuron depends on the weighted sum of all its inputs:\n\nwhere formula_38 and formula_57 are the weights on the connection from the input units to the output unit. Therefore, the error also depends on the incoming weights to the neuron, which is ultimately what needs to be changed in the network to enable learning. If each weight is plotted on a separate horizontal axis and the error on the vertical axis, the result is a parabolic bowl. For a neuron with weights, the same plot would require an elliptic paraboloid of formula_58 dimensions.\n\nOne commonly used algorithm to find the set of weights that minimizes the error is gradient descent. Backpropagation is then used to calculate the steepest descent direction.\n\nThe gradient descent method involves calculating the derivative of the squared error function with respect to the weights of the network. This is normally done using backpropagation. Assuming one output neuron, the squared error function is:\n\nwhere\n\nThe factor of formula_63 is included to cancel the exponent when differentiating. Later, the expression will be multiplied with an arbitrary learning rate, so that it doesn't matter if a constant coefficient is introduced now.\n\nFor each neuron formula_64, its output formula_65 is defined as\n\nThe input formula_67 to a neuron is the weighted sum of outputs formula_68 of previous neurons. If the neuron is in the first layer after the input layer, the formula_68 of the input layer are simply the inputs formula_70 to the network. The number of input units to the neuron is formula_18. The variable formula_72 denotes the weight between neurons formula_73 and formula_64.\n\nThe activation function formula_75 is non-linear and differentiable. A commonly used activation function is the logistic function:\n\nwhich has a convenient derivative of:\n\nCalculating the partial derivative of the error with respect to a weight formula_78 is done using the chain rule twice:\n\nIn the last factor of the right-hand side of the above, only one term in the sum formula_67 depends on formula_78, so that \n\nIf the neuron is in the first layer after the input layer, formula_83 is just formula_84.\n\nThe derivative of the output of neuron formula_64 with respect to its input is simply the partial derivative of the activation function (assuming here that the logistic function is used):\n\nThis is the reason why backpropagation requires the activation function to be differentiable.\n\nThe first factor is straightforward to evaluate if the neuron is in the output layer, because then formula_87 and\n\nHowever, if formula_64 is in an arbitrary inner layer of the network, finding the derivative formula_60 with respect to formula_65 is less obvious.\n\nConsidering formula_60 as a function of the inputs of all neurons formula_93 receiving input from neuron formula_64, \n\nand taking the total derivative with respect to formula_65, a recursive expression for the derivative is obtained:\n\nTherefore, the derivative with respect to formula_65 can be calculated if all the derivatives with respect to the outputs formula_99 of the next layer – the one closer to the output neuron – are known.\n\nPutting it all together:\n\nwith\n\nTo update the weight formula_78 using gradient descent, one must choose a learning rate, formula_103. The change in weight, which is added to the old weight, is equal to the product of the learning rate and the gradient, multiplied by formula_104:\n\nThe formula_106 is required in order to update in the direction of a minimum, not a maximum, of the error function.\n\nFor a single-layer network, this expression becomes the Delta Rule.\n\nThe choice of learning rate formula_107 is important, since a high value can cause too strong a change, causing the minimum to be missed, while a too low learning rate slows the training unnecessarily.\n\nOptimizations such as Quickprop are primarily aimed at speeding up error minimization; other improvements mainly try to increase reliability.\n\nIn order to avoid oscillation inside the network such as alternating connection weights, and to improve the rate of convergence, refinements of this algorithm use an adaptive learning rate.\n\nBy using a variable inertia term \"(Momentum)\" formula_108 the gradient and the last change can be weighted such that the weight adjustment additionally depends on the previous change. If the \"Momentum\" formula_108 is equal to 0, the change depends solely on the gradient, while a value of 1 will only depend on the last change.\n\nSimilar to a ball rolling down a mountain, whose current speed is determined not only by the current slope of the mountain but also by its own inertia, inertia can be added:formula_110where:\n\nInertia depends on the current weight change formula_126 both from the current gradient of the error function (slope of the mountain, 1st summand), as well as from the weight change from the previous point in time (inertia, 2nd summand).\n\nWith inertia, the problems of getting stuck (in steep ravines and flat plateaus) are avoided. Since, for example, the gradient of the error function becomes very small in flat plateaus, inertia would immediately lead to a \"deceleration\" of the gradient descent. This deceleration is delayed by the addition of the inertia term so that a flat plateau can be escaped more quickly.\n\nTwo modes of learning are available: stochastic and batch. In stochastic learning, each input creates a weight adjustment. In batch learning weights are adjusted based on a batch of inputs, accumulating errors over the batch. Stochastic learning introduces \"noise\" into the gradient descent process, using the local gradient calculated from one data point; this reduces the chance of the network getting stuck in a local minima. However, batch learning typically yields a faster, more stable descent to a local minima, since each update is performed in the direction of the average error of the batch. A common compromise choice is to use \"mini-batches\", meaning small batches and with samples in each batch selected stochastically from the entire data set.\n\n\nAccording to various sources, the basics of continuous backpropagation were derived in the context of control theory by Henry J. Kelley in 1960 and by Arthur E. Bryson in 1961. They used principles of dynamic programming. In 1962, Stuart Dreyfus published a simpler derivation based only on the chain rule. Bryson and Ho described it as a multi-stage dynamic system optimization method in 1969.\n\nIn 1970 Linnainmaa published the general method for automatic differentiation (AD) of discrete connected networks of nested differentiable functions. This corresponds to backpropagation, which is efficient even for sparse networks.\n\nIn 1973 Dreyfus used backpropagation to adapt parameters of controllers in proportion to error gradients. In 1974 Werbos mentioned the possibility of applying this principle to artificial neural networks, and in 1982 he applied Linnainmaa's AD method to neural networks in the way that is used today.\n\nIn 1986 Rumelhart, Hinton and Williams showed experimentally that this method can generate useful internal representations of incoming data in hidden layers of neural networks. In 1993, Wan was the first to win an international pattern recognition contest through backpropagation.\n\nDuring the 2000s it fell out of favour, but returned in the 2010s, benefitting from cheap, powerful GPU-based computing systems.\n\n\n","id":"1360091","title":"Backpropagation"}]
